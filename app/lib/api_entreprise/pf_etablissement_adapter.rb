class APIEntreprise::PfEtablissementAdapter < APIEntreprise::Adapter
  private

  def get_resource
    if @siret.present?
      no_tahiti = @siret.to_s[0..5]
      pf_api.entreprise(no_tahiti)
    else
      {}
    end
  end

  def pf_api
    @api ||= APIEntreprise::PfAPI.new
  end

  def process_params
    num_etablissement = @siret.to_s[6..9]
    list_etablissements = data_source.sort_by { |a| a[:numEtablissement] }.filter { |h| h[:dateRadiation].nil? }
    etablissement = {}

    etablissements = list_etablissements.dup

    if num_etablissement.present?
      num_etablissement = num_etablissement.to_i
      etablissements = [etablissements.find { |e| e[:numEtablissement] == num_etablissement }].compact
    end
    return [nil, nil] if etablissements.blank?

    translated_etablissements = etablissements.map { |e| translate(e) }
    fields = Set.new(translated_etablissements.map(&:keys).flatten)
    # for each field, concatenate the value of each etablissement (remove duplicates)
    fields.each { |k| etablissement[k] = merge_values(translated_etablissements, k) }

    if translated_etablissements.size == 1

      etablissement[:siege_social] = true if etablissements[0][:communeGeo][:id] == etablissements[0][:entreprise][:commune][:id] && list_etablissements.count { |e| e[:communeGeo][:id] == e[:entreprise][:commune][:id] } == 1

      etablissement[:siret] += format("%03d", etablissement[:num_entreprise])
    end
    etablissement.delete(:num_entreprise)
    [etablissement, translated_etablissements]
  end

  def merge_values(etablissements, k)
    if value_must_be_unique(k)
      etablissements.find { |e| e.key?(k) }[k] || ''
    else
      Set.new(etablissements.filter_map { |e| e[k].presence }).to_a.join(' | ')
    end
  end

  def value_must_be_unique(k)
    k.to_s.include?('date')
  end

  def translation_map
    {
      :siret => 'entreprise.numeroTahiti', # TODO with num etablissement ??
      :num_entreprise => 'numEtablissement',
      :entreprise_nom_commercial => 'nomCommercial',
      :numero_voie => 'numero_voie', # generated by normalize_street
      :nom_voie => 'nom_voie', # generated by normalize_street
      :code_postal => 'codePostal', # generated by normalize_postal
      :code_insee_localite => 'codeInseeLocalite', # generated by normalize_postal
      :localite => 'communeGeo.communeAssociee', # generated by normalize_postal
      :adresse => 'adressePostale()+pointKilometrique(PK)+numero_voie()+nom_voie()+immeuble+quartier+adresseGeo()+communeGeo.communeAssociee()',
      :entreprise_siren => 'entreprise.numeroTahiti',
      :entreprise_siret_siege_social => 'entreprise.numeroTahiti',
      :entreprise_raison_sociale => 'entreprise.raisonSociale',
      :entreprise_forme_juridique => 'entreprise.formeJuridique.libelle',
      :entreprise_forme_juridique_code => 'entreprise.formeJuridique.code',
      :entreprise_code_effectif_entreprise => 'entreprise.classeEffectif.id',
      :entreprise_date_creation => 'dateInscription',
      :entreprise_nom => '',
      :entreprise_prenom => '',
      # :entreprise_inline_adresse => '',
      :entreprise_numero_tva_intracommunautaire => '',
      :libelle_naf => 'activitePrincipale.libelle',
      :naf => 'activitePrincipale.code'
    }
  end

  # noinspection RubyLiteralArrayInspection
  NOM_VOIES = [
    'avenue', 'av', 'angle', 'rue', 'boulevard', 'chemin', 'ave', 'bvd', 'cours', 'place', 'allée', 'route', 'immeuble',
    'lot', 'passage', 'servitude', 'blvd', 'pointe', 'pont', 'av.', 'bd', 'blv', 'ecole', 'école', 'église'
  ]
  NOM_VOIES_RE = NOM_VOIES.join('|')

  def translate(json)
    normalize_street(json)
    normalize_postal(json)

    etablissement = {}
    translation_map.each do |fr, pf|
      concatenation = pf.include? '+'
      pf.split('+').each do |expression|
        value = json
        variable = expression
        label = expression
        expression.split('.').each do |key|
          # 'variable(label)' or 'variable'
          /(?<variable>[^(]+)(?:\((?<label>[^)]*)\))?/ =~ key
          value = value[variable.to_sym] if value
        end
        if value.present?
          add_value(etablissement, fr, get_value(value, concatenation, label, variable))
        end
      end
      etablissement[fr] ||= ''
    end
    etablissement
  end

  def add_value(hash, key, value)
    if hash[key].present?
      hash[key] += ", " + value
    else
      hash[key] = value.dup
    end
  end

  def get_value(value, concatenation, label, default_label)
    if concatenation
      label ||= default_label.gsub(/\p{Lu}+/) { |w| ' ' + w.downcase }
      if label.present?
        value = label + ' ' + value.to_s
      end
    end
    value
  end

  # generate :numero_voie & :nom_voie entries from :rue value
  def normalize_street(json)
    if (rue = json[:rue]).present? && !rue.include?('null')
      json[:numero_voie] = rue[/^\s*(\d+)/, 1]
      voie = rue[/^[ \d]*(.*)/, 1]
      if !/^(#{NOM_VOIES_RE})/i.match?(voie)
        voie = 'rue ' + voie
      end
      json[:nom_voie] = voie
    end
  end

  # generate :code_postal & :commune entries from :adressePostale
  def normalize_postal(etablissement)
    entreprise = etablissement[:entreprise]
    etablissement[:boitePostale] = entreprise[:boitePostale] if etablissement[:boitePostale].nil?
    etablissement[:adressePostale] = entreprise[:adressePostale] if etablissement[:adressePostale].nil?
    if (ap = etablissement[:adressePostale]).present?
      etablissement[:codePostal] = ap[/^\s*(\d+)/, 1]
      etablissement[:communePostale] = ap[/^[ \d]*(.*)/, 1]
      etablissement[:adressePostale] = "BP #{etablissement[:boitePostale]}, #{etablissement[:adressePostale]}" if etablissement[:boitePostale].present?
    end
    etablissement[:codeInseeLocalite] = "0" # No insee code in i-taiete
  end
end
