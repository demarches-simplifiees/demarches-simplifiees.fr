%li.type-de-champ.flex.column.justify-start.fr-mb-5v{ html_options }
  .type-de-champ-container{ id: dom_id(type_de_champ.stable_self, :editor_error) }
    - if @errors.present?
      .types-de-champ-errors
        = @errors

    .flex.justify-start.section.head
      = form_for(type_de_champ, form_options) do |form|
        .flex.justify-start.flex-gap.fr-mb-4w
          .flex.justify-start.width-33
            .cell.flex.justify-start.column.flex-grow
              = form.label :type_champ, "Type de champ", for: dom_id(type_de_champ, :type_champ)
              = form.select :type_champ, grouped_options_for_select(types_of_type_de_champ, type_de_champ.type_champ), {}, class: 'fr-select small-margin small inline width-100', id: dom_id(type_de_champ, :type_champ), disabled: coordinate.used_by_routing_rules? || coordinate.used_by_ineligibilite_rules?

              - if type_de_champ.siret?
                .cell.fr-mt-1w
                  = button_tag("Liste des informations remontées", type: :button, class: "fr-btn fr-icon-info-line fr-btn--icon-left fr-btn--tertiary-no-outline fr-btn--sm",
                    data: { "fr-opened" => "false", "turbo-frame" => "api-champ-columns", action: "lazy-modal#load" },
                    src: api_champ_columns_admin_procedure_path(id: procedure.id, stable_id: type_de_champ.stable_id),
                    "aria-controls" => "api-champ-columns-modal")

          .flex.column.justify-start.flex-grow
            .cell
              .flex.align-center
                = form.label :libelle, "Libellé du champ", class: 'flex-grow', for: dom_id(type_de_champ, :libelle)
                - if can_be_mandatory?
                  .cell.flex.align-center
                    = form.check_box :mandatory, class: 'small-margin small', id: dom_id(type_de_champ, :mandatory)
                    = form.label :mandatory, "Champ obligatoire", for: dom_id(type_de_champ, :mandatory)
              = form.text_field :libelle, class: 'fr-input small-margin small width-100', id: dom_id(type_de_champ, :libelle), data: input_autofocus
            - if type_de_champ.header_section?
              %p
                %small Nous numérotons automatiquement les titres lorsqu’aucun de vos titres ne commence par un chiffre.

            - if !type_de_champ.header_section? && !type_de_champ.titre_identite?
              .cell.fr-mt-1w
                = form.label :description, "Description du champ (optionnel)", for: dom_id(type_de_champ, :description)
                = form.text_area :description, class: 'fr-input small-margin small width-100 resize-y', rows: 3, id: dom_id(type_de_champ, :description)
            - if type_de_champ.header_section?
              .cell.fr-mt-1w
                = render TypesDeChampEditor::HeaderSectionComponent.new(form: form, tdc: type_de_champ, upper_tdcs: @upper_coordinates.map(&:type_de_champ))
            - if type_de_champ.explication?
              .cell.fr-mt-2w
                .fr-toggle
                  = form.check_box :collapsible_explanation_enabled, id: dom_id(type_de_champ, :collapsible_explanation_enabled), class: 'fr-toggle__input'
                  = form.label :collapsible_explanation_enabled, "Afficher un texte complémentaire affichable au clic", for: dom_id(type_de_champ, :collapsible_explanation_enabled), class: 'fr-toggle__label fr-label'

                - if form.object.collapsible_explanation_enabled?
                  .cell.fr-mt-1w
                    = form.label :collapsible_explanation_text, for: dom_id(type_de_champ, :collapsible_explanation_text) do
                      = "Texte complémentaire"
                    = form.text_area :collapsible_explanation_text, class: "fr-input small-margin small", id: dom_id(type_de_champ, :collapsible_explanation_text)
              .cell.fr-mt-1w
                = form.label :notice_explicative, "Notice explicative", for: dom_id(type_de_champ, :notice_explicative)
                = render Attachment::EditComponent.new(**notice_explicative_options)

            - if type_de_champ.piece_justificative?
              .cell.fr-mt-1w
                = form.label :nature, "Nature de la pièce", for: dom_id(type_de_champ, :nature)
                - natures = TypeDeChamp.natures.keys.map { |k| [t("activerecord.attributes.type_de_champ.natures.#{k}", default: k.to_s.humanize), k] }
                = form.select :nature,
                  natures,
                  { },
                  class: 'fr-select small-margin small inline width-100',
                  id: dom_id(type_de_champ, :nature)
              - nature_dom_id = dom_id(type_de_champ, :nature)
              - if type_de_champ.titre_identite_nature?
                .cell.fr-mt-2w
                  = render Dsfr::NoticeComponent.new(state: 'info') do |c|
                    - c.with_title do
                      = t('.identity_notice.title')
                    - c.with_desc do
                      = t('.identity_notice.desc_html')

                .fr-hr.fr-mt-2w
                .cell
                  = form.label :formats_accepted, t('.identity_formats.title'), for: nature_dom_id, class: 'fake-label'
                  %p.fr-mb-0= t('.identity_formats.desc_html')
                  %p.fr-mt-0= t('.identity_formats.rule_html')
                .fr-hr.fr-mt-1w
                .cell
                  = form.label :deletion_title, t('.identity_deletion.title'), for: nature_dom_id, class: 'fake-label'
                  %p.fr-mb-0= t('.identity_deletion.desc_html')
                  %p.fr-mt-0= t('.identity_deletion.note_html')
              - elsif type_de_champ.rib_nature?
                .cell.fr-mt-2w
                  = render Dsfr::NoticeComponent.new(state: 'info') do |c|
                    - c.with_title do
                      = t('.identity_notice.title')
                    - c.with_desc do
                      = t('.rib_notice.desc_html')
                .fr-hr.fr-mt-2w
                .cell
                  = form.label :formats_accepted, t('.rib_formats.title'), for: nature_dom_id, class: 'fake-label'
                  %p.fr-mb-0= t('.rib_formats.desc_html')
                .fr-hr.fr-mt-2w
              - else
                .cell.fr-mt-2w{ data: { controller: 'hide-target' } }
                  .fr-toggle
                    = form.check_box :pj_limit_formats,
                      id: dom_id(type_de_champ, :pj_limit_formats),
                      class: 'fr-toggle__input',
                      data: { 'hide-target-target': 'source' },
                      checked: form.object.pj_limit_formats?
                    = form.label :pj_limit_formats, t('.limit_formats_label'), for: dom_id(type_de_champ, :pj_limit_formats), class: 'fr-toggle__label fr-label'

                  - families = format_families_for_select
                  - grid_hidden_class = form.object.pj_limit_formats? ? nil : 'fr-hidden'
                  .cell.fr-mt-1w{ class: grid_hidden_class, data: { 'hide-target-target': 'toHide' } }
                    %fieldset.fr-fieldset
                      %legend.fake-label
                        = t('.families_legend')
                      .fr-fieldset__content
                        .fr-grid-row.fr-grid-row--gutters
                          - prechecked = Array.wrap(form.object.pj_format_families).map(&:to_s)
                          - families.each do |(value, label, examples)|
                            .fr-col-12.fr-col-sm-6.fr-col-md-3
                              .fr-checkbox-group
                                - checked_opt = prechecked.include?(value.to_s)
                                = form.check_box :pj_format_families, { multiple: true, id: dom_id(type_de_champ, "pj_format_#{value}"), checked: checked_opt }, value, nil
                                - if examples.present?
                                  - tip_id = "#{dom_id(type_de_champ, "pj_format_#{value}")}-tip"
                                  = form.label "pj_format_families_#{value}", label, for: dom_id(type_de_champ, "pj_format_#{value}"), class: 'fr-label', tabindex: 0, 'aria-describedby': tip_id
                                  %span.fr-tooltip.fr-placement{ id: tip_id, role: 'tooltip', 'aria-hidden': 'true' }= t('.tooltip_examples', examples: examples)
                                - else
                                  = form.label "pj_format_families_#{value}", label, for: dom_id(type_de_champ, "pj_format_#{value}"), class: 'fr-label'

              - if !type_de_champ.titre_identite_nature?
                .cell.fr-mt-2w
                  .fr-toggle
                    = form.check_box :pj_auto_purge, id: dom_id(type_de_champ, :pj_auto_purge), class: 'fr-toggle__input'
                    = form.label :pj_auto_purge, t('.auto_purge_label'), for: dom_id(type_de_champ, :pj_auto_purge), class: 'fr-toggle__label fr-label'

            - if type_de_champ.piece_justificative_or_titre_identite?
              .cell.fr-mt-1w
                .fr-hr.fr-mt-1w
                = form.label :piece_justificative_template, t('.template_label'), for: dom_id(type_de_champ, :piece_justificative_template)
                = render Attachment::EditComponent.new(**piece_justificative_template_options)


            - if type_de_champ.integer_number? || type_de_champ.decimal_number?
              .border-left-dark.fr-mt-2w
                .cell
                  %legend.fake-label
                    Format accepté
                  .fr-toggle
                    = form.check_box :positive_number, id: dom_id(type_de_champ, :positive_number), class: 'fr-toggle__input'
                    = form.label :positive_number, "Ce nombre doit être positif", for: dom_id(type_de_champ, :positive_number), class: 'fr-toggle__label fr-label'

                .cell.fr-mt-2w
                  .fr-toggle
                    = form.check_box :range_number, id: dom_id(type_de_champ, :range_number), class: 'fr-toggle__input'
                    = form.label :range_number, "Ce nombre doit être compris entre des valeurs limites", for: dom_id(type_de_champ, :range_number), class: 'fr-toggle__label fr-label'

                - if form.object.range_number?
                  .cell.fr-mt-1w
                    %fieldset.fr-fieldset
                      .fr-fieldset__element.fr-fieldset__element--inline.fr-mb-0
                        .fr-input-group
                          = form.label :min_number, for: dom_id(type_de_champ, :min_number) do
                            valeur minimale
                          = form.number_field :min_number, class: "fr-input", id: dom_id(type_de_champ, :min_number)

                      .fr-fieldset__element.fr-fieldset__element--inline.fr-mb-0
                        .fr-input-group
                          = form.label :max_number, for: dom_id(type_de_champ, :max_number) do
                            valeur maximale
                          = form.number_field :max_number, class: "fr-input", id: dom_id(type_de_champ, :max_number)

            - if type_de_champ.date? || type_de_champ.datetime?
              .border-left-dark.fr-mt-2w
                .cell
                  %legend.fake-label
                    Format accepté
                  .fr-toggle
                    = form.check_box :date_in_past, id: dom_id(type_de_champ, :date_in_past), class: 'fr-toggle__input'
                    = form.label :date_in_past, "Cette date doit être dans le passé", for: dom_id(type_de_champ, :date_in_past), class: 'fr-toggle__label fr-label'

                .cell.fr-mt-2w
                  .fr-toggle
                    = form.check_box :range_date, id: dom_id(type_de_champ, :range_date), class: 'fr-toggle__input'
                    = form.label :range_date, "Cette date doit être comprise entre des dates limites", for: dom_id(type_de_champ, :range_date), class: 'fr-toggle__label fr-label'

                - if form.object.range_date?
                  .cell.fr-mt-1w
                    %fieldset.fr-fieldset
                      .fr-fieldset__element.fr-fieldset__element--inline.fr-mb-0
                        .fr-input-group
                          = form.label :start_date, for: dom_id(type_de_champ, :start_date) do
                            date de début
                          = form.date_field :start_date, class: "fr-input", value: type_de_champ.start_date, id: dom_id(type_de_champ, :start_date)

                      .fr-fieldset__element.fr-fieldset__element--inline.fr-mb-0
                        .fr-input-group
                          = form.label :end_date, for: dom_id(type_de_champ, :end_date) do
                            date de fin
                          = form.date_field :end_date, class: "fr-input", value: type_de_champ.end_date, id: dom_id(type_de_champ, :end_date)

        .flex.justify-start.fr-mt-1w.flex-gap
          - if type_de_champ.linked_drop_down_list?
            .flex.column.justify-start.width-33
              .cell
                = form.label :drop_down_options_from_text, "Options de la liste", for: dom_id(type_de_champ, :drop_down_options_from_text)
                = form.text_area :drop_down_options_from_text,
                  value: type_de_champ.drop_down_options.join("\r\n"),
                  class: 'fr-input small-margin small width-100',
                  rows: 7,
                  id: dom_id(type_de_champ, :drop_down_options_from_text)
          - elsif type_de_champ.drop_down_list? || type_de_champ.multiple_drop_down_list?
            .flex.justify-start.column.width-33.fr-mt-1w
              .cell
                %fieldset.fr-segmented.fr-segmented
                  %legend.fr-segmented__legend
                    Liste de choix
                  .fr-segmented__elements
                    .fr-segmented__element
                      = form.radio_button :drop_down_mode, 'simple', checked: type_de_champ.drop_down_simple?, id: dom_id(type_de_champ, :simple)
                      = form.label :drop_down_mode_simple, t('.drop_down_list.labels.simple'), for: dom_id(type_de_champ, :simple), class: 'fr-label'
                    .fr-segmented__element
                      = form.radio_button :drop_down_mode, 'advanced', id: dom_id(type_de_champ, :advanced)
                      = form.label :drop_down_mode_advanced, t('.drop_down_list.labels.advanced'), for: dom_id(type_de_champ, :advanced), class: 'fr-label'

            .flex.column.justify-start.flex-grow.border-left-dark.fr-my-1w
              = render TypesDeChampEditor::ChampDropDownSimpleComponent.new(type_de_champ:, form:, procedure:)
              = render TypesDeChampEditor::ChampDropDownAdvancedComponent.new(type_de_champ:, form:, procedure:)

              - if type_de_champ.drop_down_list?
                .cell.flex.align-center
                  = form.check_box :drop_down_other, class: "small-margin small", id: dom_id(type_de_champ, :drop_down_other)
                  = form.label :drop_down_other, for: dom_id(type_de_champ, :drop_down_other) do
                    Proposer une option « autre » avec un texte libre

          - if type_de_champ.linked_drop_down_list?
            .flex.column.justify-start.flex-grow
              .cell
                = form.label :drop_down_secondary_libelle, "Libellé du champ secondaire", class: 'flex-grow', for: dom_id(type_de_champ, :drop_down_secondary_libelle)
                = form.text_field :drop_down_secondary_libelle, class: 'fr-input small-margin small width-100', id: dom_id(type_de_champ, :drop_down_secondary_libelle)
              .cell.fr-mt-1w
                = form.label :drop_down_secondary_description, "Description du champ secondaire (optionnel)", for: dom_id(type_de_champ, :drop_down_secondary_description)
                = form.text_area :drop_down_secondary_description, class: 'fr-input small-margin small width-100', rows: 3, id: dom_id(type_de_champ, :drop_down_secondary_description)
          - if type_de_champ.carte?
            - type_de_champ.editable_options.each do |slice|
              .cell
                .carte-options
                  = form.fields_for :editable_options do |form|
                    - slice.each do |(name, checked)|
                      = form.label name, for: dom_id(type_de_champ, "layer_#{name}") do
                        = form.check_box name, checked: checked, class: 'small-margin small', id: dom_id(type_de_champ, "layer_#{name}")
                        = t(".layers.#{name}")
          - if type_de_champ.textarea?
            .cell
              = form.label :character_limit, for: dom_id(type_de_champ, :character_limit) do
                Spécifier un nombre maximal conseillé de caractères :
              = form.select :character_limit, options_for_character_limit, {}, { id: dom_id(type_de_champ, :character_limit), class: 'fr-select' }
          - if type_de_champ.formatted?
            .flex.justify-start.column.width-33
              %fieldset.fr-segmented.fr-segmented
                %legend.fr-segmented__legend.fr-mb-1w
                  Spécifier le format requis
                .fr-segmented__elements
                  .fr-segmented__element
                    = form.radio_button :formatted_mode, 'simple', checked: type_de_champ.formatted_simple?, id: dom_id(type_de_champ, :simple)
                    = form.label :formatted_mode_simple, t('.kind.labels.simple'), for: dom_id(type_de_champ, :simple), class: 'fr-label'
                  .fr-segmented__element
                    = form.radio_button :formatted_mode, 'advanced', id: dom_id(type_de_champ, :advanced)
                    = form.label :formatted_mode_advanced, t('.kind.labels.advanced'), for: dom_id(type_de_champ, :advanced), class: 'fr-label'

            = render TypesDeChampEditor::ChampFormattedSimpleComponent.new(type_de_champ:, form:, procedure:)
            = render TypesDeChampEditor::ChampFormattedAdvancedComponent.new(type_de_champ:, form:, procedure:)

    - if type_de_champ.referentiel?
      = render(TypesDeChampEditor::InfoReferentielComponent.new(procedure:, type_de_champ:))

    - if type_de_champ.repetition?
      .flex.justify-start.section.fr-ml-1w
        .editor-block.flex-grow.cell
          = render TypesDeChampEditor::BlockComponent.new(block: coordinate, coordinates: coordinate.revision_types_de_champ, upper_coordinates: @upper_coordinates)
          .type-de-champ-add-button{ id: dom_id(coordinate, :type_de_champ_add_button), class: class_names(hidden: !coordinate.empty?) }
            = render TypesDeChampEditor::AddChampButtonComponent.new(revision: coordinate.revision, parent: coordinate, is_annotation: coordinate.private?)

    = render(Conditions::ChampsConditionsComponent.new(tdc: type_de_champ, upper_tdcs: @upper_coordinates.map(&:type_de_champ), procedure_id: procedure.id))

    .flex.justify-between.section.footer
      .position.flex.align-center= (@coordinate.position + 1).to_s
      %button.fr-btn.fr-btn--tertiary-no-outline.fr-icon-arrow-up-line.move-up{ move_button_options(:up) }
      %button.fr-btn.fr-btn--tertiary-no-outline.fr-icon-arrow-down-line.move-down{ move_button_options(:down) }
      = render TypesDeChampEditor::SelectChampPositionComponent.new(revision:, coordinate:)

      .flex.right
        - if coordinate.used_by_routing_rules?
          %span
            utilisé pour
            = link_to('le routage', admin_procedure_groupe_instructeurs_path(revision.procedure_id, anchor: 'routing-rules'))
        - elsif coordinate.used_by_ineligibilite_rules?
          %span
            utilisé pour
            = link_to('l’eligibilité des dossiers', edit_admin_procedure_ineligibilite_rules_path(revision.procedure_id))
        - else
          - if coordinate.prefilled_by_type_de_champ
            %span
              = "Champ prérempli (référentiel)"

          = button_to type_de_champ_path, class: 'fr-btn fr-btn--tertiary-no-outline fr-icon-delete-line', title: "Supprimer le champ", method: :delete, form: { data: { turbo_confirm: } } do
            %span.sr-only Supprimer

  .type-de-champ-add-button{ class: class_names(root: !coordinate.child?, flex: true) }
    = render TypesDeChampEditor::AddChampButtonComponent.new(revision: coordinate.revision, parent: coordinate&.parent, is_annotation: coordinate.private?, after_stable_id: type_de_champ.stable_id)
