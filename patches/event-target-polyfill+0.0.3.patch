diff --git a/node_modules/event-target-polyfill/index.js b/node_modules/event-target-polyfill/index.js
index 82f7f42..8e29c96 100644
--- a/node_modules/event-target-polyfill/index.js
+++ b/node_modules/event-target-polyfill/index.js
@@ -1,7 +1,20 @@
-const root =
-  (typeof globalThis !== "undefined" && globalThis) ||
-  (typeof self !== "undefined" && self) ||
-  (typeof global !== "undefined" && global);
+"use strict";
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+var root = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
 
 function isConstructor(fn) {
   try {
@@ -9,66 +22,49 @@ function isConstructor(fn) {
   } catch (error) {
     return false;
   }
-  return true;
-}
-
-if (typeof root.Event !== "function" || !isConstructor(root.Event)) {
-  root.Event = (function () {
-    function Event(type, options) {
-        this.bubbles = !!options && !!options.bubbles;
-        this.cancelable = !!options && !!options.cancelable;
-        this.composed = !!options && !!options.composed;
-      this.type = type;
-    }
 
-    return Event;
-  })();
+  return true;
 }
 
 if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
-  root.EventTarget = (function () {
+  root.EventTarget = function () {
     function EventTarget() {
       this.__listeners = new Map();
     }
 
     EventTarget.prototype = Object.create(Object.prototype);
 
-    EventTarget.prototype.addEventListener = function (
-      type,
-      listener,
-      options
-    ) {
+    EventTarget.prototype.addEventListener = function (type, listener, options) {
       if (arguments.length < 2) {
-        throw new TypeError(
-          `TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`
-        );
+        throw new TypeError("TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ".concat(arguments.length, " present."));
       }
-      const __listeners = this.__listeners;
-      const actualType = type.toString();
+
+      var __listeners = this.__listeners;
+      var actualType = type.toString();
+
       if (!__listeners.has(actualType)) {
         __listeners.set(actualType, new Map());
       }
-      const listenersForType = __listeners.get(actualType);
+
+      var listenersForType = __listeners.get(actualType);
+
       if (!listenersForType.has(listener)) {
         // Any given listener is only registered once
         listenersForType.set(listener, options);
       }
     };
 
-    EventTarget.prototype.removeEventListener = function (
-      type,
-      listener,
-      _options
-    ) {
+    EventTarget.prototype.removeEventListener = function (type, listener, _options) {
       if (arguments.length < 2) {
-        throw new TypeError(
-          `TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`
-        );
+        throw new TypeError("TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ".concat(arguments.length, " present."));
       }
-      const __listeners = this.__listeners;
-      const actualType = type.toString();
+
+      var __listeners = this.__listeners;
+      var actualType = type.toString();
+
       if (__listeners.has(actualType)) {
-        const listenersForType = __listeners.get(actualType);
+        var listenersForType = __listeners.get(actualType);
+
         if (listenersForType.has(listener)) {
           listenersForType.delete(listener);
         }
@@ -77,45 +73,61 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
 
     EventTarget.prototype.dispatchEvent = function (event) {
       if (!(event instanceof Event)) {
-        throw new TypeError(
-          `Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'.`
-        );
+        throw new TypeError("Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'.");
       }
-      const type = event.type;
-      const __listeners = this.__listeners;
-      const listenersForType = __listeners.get(type);
+
+      var type = event.type;
+      var __listeners = this.__listeners;
+
+      var listenersForType = __listeners.get(type);
+
       if (listenersForType) {
-        for (const [listener, options] of listenersForType.entries()) {
-          try {
-            if (typeof listener === "function") {
-              // Listener functions must be executed with the EventTarget as the `this` context.
-              listener.call(this, event);
-            } else if (listener && typeof listener.handleEvent === "function") {
-              // Listener objects have their handleEvent method called, if they have one
-              listener.handleEvent(event);
+        var _iterator = _createForOfIteratorHelper(listenersForType.entries()),
+            _step;
+
+        try {
+          for (_iterator.s(); !(_step = _iterator.n()).done;) {
+            var _step$value = _slicedToArray(_step.value, 2),
+                listener = _step$value[0],
+                options = _step$value[1];
+
+            try {
+              if (typeof listener === "function") {
+                // Listener functions must be executed with the EventTarget as the `this` context.
+                listener.call(this, event);
+              } else if (listener && typeof listener.handleEvent === "function") {
+                // Listener objects have their handleEvent method called, if they have one
+                listener.handleEvent(event);
+              }
+            } catch (err) {
+              // We need to report the error to the global error handling event,
+              // but we do not want to break the loop that is executing the events.
+              // Unfortunately, this is the best we can do, which isn't great, because the
+              // native EventTarget will actually do this synchronously before moving to the next
+              // event in the loop.
+              setTimeout(function () {
+                throw err;
+              });
+            }
+
+            if (options && options.once) {
+              // If this was registered with { once: true }, we need
+              // to remove it now.
+              listenersForType.delete(listener);
             }
-          } catch (err) {
-            // We need to report the error to the global error handling event,
-            // but we do not want to break the loop that is executing the events.
-            // Unfortunately, this is the best we can do, which isn't great, because the
-            // native EventTarget will actually do this synchronously before moving to the next
-            // event in the loop.
-            setTimeout(() => {
-              throw err;
-            });
-          }
-          if (options && options.once) {
-            // If this was registered with { once: true }, we need
-            // to remove it now.
-            listenersForType.delete(listener);
           }
+        } catch (err) {
+          _iterator.e(err);
+        } finally {
+          _iterator.f();
         }
-      }
-      // Since there are no cancellable events on a base EventTarget,
+      } // Since there are no cancellable events on a base EventTarget,
       // this should always return true.
+
+
       return true;
     };
 
     return EventTarget;
-  })();
+  }();
 }
