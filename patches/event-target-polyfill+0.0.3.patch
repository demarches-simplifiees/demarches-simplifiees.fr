diff --git a/node_modules/event-target-polyfill/index.js b/node_modules/event-target-polyfill/index.js
index 82f7f42..d198834 100644
--- a/node_modules/event-target-polyfill/index.js
+++ b/node_modules/event-target-polyfill/index.js
@@ -12,19 +12,6 @@ function isConstructor(fn) {
   return true;
 }
 
-if (typeof root.Event !== "function" || !isConstructor(root.Event)) {
-  root.Event = (function () {
-    function Event(type, options) {
-        this.bubbles = !!options && !!options.bubbles;
-        this.cancelable = !!options && !!options.cancelable;
-        this.composed = !!options && !!options.composed;
-      this.type = type;
-    }
-
-    return Event;
-  })();
-}
-
 if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
   root.EventTarget = (function () {
     function EventTarget() {
@@ -40,7 +27,8 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
     ) {
       if (arguments.length < 2) {
         throw new TypeError(
-          `TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`
+          "TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, " +
+          "but only " + arguments.length.toString() + "present."
         );
       }
       const __listeners = this.__listeners;
@@ -62,7 +50,8 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
     ) {
       if (arguments.length < 2) {
         throw new TypeError(
-          `TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, but only ${arguments.length} present.`
+          "TypeError: Failed to execute 'addEventListener' on 'EventTarget': 2 arguments required, " +
+          "but only " + arguments.length.toString() + "present."
         );
       }
       const __listeners = this.__listeners;
@@ -78,14 +67,14 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
     EventTarget.prototype.dispatchEvent = function (event) {
       if (!(event instanceof Event)) {
         throw new TypeError(
-          `Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'.`
+          "Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'."
         );
       }
       const type = event.type;
       const __listeners = this.__listeners;
       const listenersForType = __listeners.get(type);
       if (listenersForType) {
-        for (const [listener, options] of listenersForType.entries()) {
+        listenersForType.forEach(function(options, listener) {
           try {
             if (typeof listener === "function") {
               // Listener functions must be executed with the EventTarget as the `this` context.
@@ -100,7 +89,7 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
             // Unfortunately, this is the best we can do, which isn't great, because the
             // native EventTarget will actually do this synchronously before moving to the next
             // event in the loop.
-            setTimeout(() => {
+            setTimeout(function() {
               throw err;
             });
           }
@@ -109,7 +98,7 @@ if (typeof root.EventTarget === "undefined" || !isConstructor(root.Event)) {
             // to remove it now.
             listenersForType.delete(listener);
           }
-        }
+        })
       }
       // Since there are no cancellable events on a base EventTarget,
       // this should always return true.
